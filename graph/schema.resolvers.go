package graph

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.85

import (
	"context"

	"github.com/jinzhu/copier"
	"github.com/tuken/nix/db"
	"github.com/tuken/nix/graph/model"
	"github.com/tuken/nix/middleware"
)

// CreateOrg is the resolver for the createOrg field.
func (r *mutationResolver) CreateOrg(ctx context.Context, input model.NewOrg) (*model.Org, error) {
	db := middleware.GetDatabase(ctx)

	newOrg := &model.Org{
		Name:       input.Name,
		PostalCode: input.PostalCode,
		Address:    input.Address,
		Note:       input.Note,
	}

	if err := db.Create(newOrg).Error; err != nil {
		return nil, err
	}

	return newOrg, nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.NewUser) (*model.User, error) {
	d := middleware.GetDatabase(ctx)

	newUser := &db.User{
		OrgID:      uint(input.OrgID),
		RoleID:     uint(input.RoleID),
		Email:      input.Email,
		Password:   input.Password,
		Name:       input.Name,
		PostalCode: input.PostalCode,
		Address:    input.Address,
		Birthday:   input.Birthday,
		Note:       input.Note,
	}

	if input.ParentID != nil {
		newUser.ParentID.Scan(*input.ParentID)
	}

	if err := d.Create(newUser).Error; err != nil {
		return nil, err
	}

	dbUser := db.User{}
	if err := d.Preload("Org").Preload("Parent").Preload("Role").First(&dbUser, newUser.ID).Error; err != nil {
		return nil, err
	}

	user := model.User{}
	copier.Copy(&user, &dbUser)

	return &user, nil
}

// CreateField is the resolver for the createField field.
func (r *mutationResolver) CreateField(ctx context.Context, input model.NewField) (*model.Field, error) {
	d := middleware.GetDatabase(ctx)

	newField := &db.Field{
		OrgID:       uint(input.OrgID),
		UserID:      uint(input.UserID),
		Name:        input.Name,
		Latitude:    input.Latitude,
		Longitude:   input.Longitude,
		Boundary:    db.Polygon{WKT: input.Boundary},
		PostalCode:  input.PostalCode,
		Address:     input.Address,
		FieldTypeID: uint(input.FeildTypeID),
		Note:        input.Note,
	}

	if input.FieldCode != nil {
		newField.FieldCode.Scan(*input.FieldCode)
	}

	if input.Elevation != nil {
		newField.Elevation.Scan(*input.Elevation)
	}

	if input.Area != nil {
		newField.Area.Scan(*input.Area)
	}

	if err := d.Create(newField).Error; err != nil {
		return nil, err
	}

	field := &model.Field{}
	copier.Copy(field, newField)

	return field, nil
}

// Orgs is the resolver for the orgs field.
func (r *queryResolver) Orgs(ctx context.Context) ([]*model.Org, error) {
	db := middleware.GetDatabase(ctx)

	var orgs []*model.Org
	if err := db.Find(&orgs).Error; err != nil {
		return nil, err
	}

	return orgs, nil
}

// Roles is the resolver for the roles field.
func (r *queryResolver) Roles(ctx context.Context) ([]*model.Role, error) {
	db := middleware.GetDatabase(ctx)

	var roles []*model.Role
	if err := db.Find(&roles).Error; err != nil {
		return nil, err
	}

	return roles, nil
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context) ([]*model.User, error) {
	d := middleware.GetDatabase(ctx)

	dbUser := []db.User{}
	if err := d.Preload("Org").Preload("Parent").Preload("Role").Find(&dbUser).Error; err != nil {
		return nil, err
	}

	user := []*model.User{}
	copier.Copy(&user, &dbUser)

	return user, nil
}

// Fields is the resolver for the fields field.
func (r *queryResolver) Fields(ctx context.Context) ([]*model.Field, error) {
	db := middleware.GetDatabase(ctx)

	var fields []*model.Field
	if err := db.Find(&fields).Error; err != nil {
		return nil, err
	}

	return fields, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
